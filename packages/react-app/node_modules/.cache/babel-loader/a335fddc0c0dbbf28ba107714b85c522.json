{"ast":null,"code":"import { useMemo } from 'react';\nimport { useChainCalls } from './useChainCalls';\nimport { useChainId } from './useChainId';\n\nfunction warnOnInvalidContractCall(call) {\n  console.warn(\"Invalid contract call: address=\".concat(call && call.address, \" method=\").concat(call && call.method, \" args=\").concat(call && call.args));\n}\n\nfunction encodeCallData(call, chainId) {\n  if (!call) {\n    return undefined;\n  }\n\n  if (!call.address || !call.method) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n\n  try {\n    return {\n      address: call.address,\n      data: call.abi.encodeFunctionData(call.method, call.args),\n      chainId: chainId\n    };\n  } catch (_a) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n}\n/**\n * Makes a call to a specific contract and returns the value. The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useChainCall} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param call a single call to a contract, also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCall} instead of this method as it is deprecated.\n * @returns the result of a call or undefined if call didn't return yet.\n */\n\n\nexport function useContractCall(call) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useContractCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific contracts and returns values. The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useChainCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls , also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCalls} instead of this method as it is deprecated.\n * @returns array of results. Undefined if call didn't return yet.\n */\n\nexport function useContractCalls(calls) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var chainId = useChainId({\n    queryParams: queryParams\n  });\n  var rawCalls = useMemo(function () {\n    return calls.map(function (call) {\n      return chainId !== undefined ? encodeCallData(call, chainId) : undefined;\n    });\n  }, [JSON.stringify(calls.map(function (call) {\n    var _a;\n\n    return call && {\n      address: (_a = call.address) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n      method: call.method,\n      args: call.args\n    };\n  })), chainId]);\n  var results = useChainCalls(rawCalls);\n  return useMemo(function () {\n    return results.map(function (result, idx) {\n      var call = calls[idx];\n\n      if (result === '0x') {\n        warnOnInvalidContractCall(call);\n        return undefined;\n      }\n\n      return call && result ? call.abi.decodeFunctionResult(call.method, result) : undefined;\n    });\n  }, [JSON.stringify(results)]);\n}","map":{"version":3,"sources":["../../../../src/hooks/useContractCall.ts"],"names":[],"mappings":"AACA,SAAS,OAAT,QAAwB,OAAxB;AAKA,SAAS,aAAT,QAA8B,iBAA9B;AACA,SAAS,UAAT,QAA2B,cAA3B;;AAEA,SAAS,yBAAT,CAAmC,IAAnC,EAA6D;EAC3D,OAAO,CAAC,IAAR,0CACoC,IAAI,IAAI,IAAI,CAAC,OADjD,qBACmE,IAAI,IAAI,IAAI,CAAC,MADhF,mBAC+F,IAAI,IAAI,IAAI,CAAC,IAD5G;AAGD;;AAED,SAAS,cAAT,CAAwB,IAAxB,EAAoD,OAApD,EAAoE;EAClE,IAAI,CAAC,IAAL,EAAW;IACT,OAAO,SAAP;EACD;;EACD,IAAI,CAAC,IAAI,CAAC,OAAN,IAAiB,CAAC,IAAI,CAAC,MAA3B,EAAmC;IACjC,yBAAyB,CAAC,IAAD,CAAzB;IACA,OAAO,SAAP;EACD;;EACD,IAAI;IACF,OAAO;MAAE,OAAO,EAAE,IAAI,CAAC,OAAhB;MAAyB,IAAI,EAAE,IAAI,CAAC,GAAL,CAAS,kBAAT,CAA4B,IAAI,CAAC,MAAjC,EAAyC,IAAI,CAAC,IAA9C,CAA/B;MAAoF,OAAO,EAAP;IAApF,CAAP;EACD,CAFD,CAEE,OAAA,EAAA,EAAM;IACN,yBAAyB,CAAC,IAAD,CAAzB;IACA,OAAO,SAAP;EACD;AACF;AAaD;;;;;;;AAOG;;;AACH,OAAM,SAAU,eAAV,CAA0B,IAA1B,EAAmF;EAAA,IAA7B,WAA6B,uEAAF,EAAE;EACvF,OAAO,gBAAgB,CAAC,CAAC,IAAD,CAAD,EAAS,WAAT,CAAhB,CAAsC,CAAtC,CAAP;AACD;AAED;;;;;;;AAOG;;AACH,OAAM,SAAU,gBAAV,CACJ,KADI,EAEyB;EAAA,IAA7B,WAA6B,uEAAF,EAAE;EAE7B,IAAM,OAAO,GAAG,UAAU,CAAC;IAAE,WAAW,EAAX;EAAF,CAAD,CAA1B;EAEA,IAAM,QAAQ,GAAG,OAAO,CACtB;IAAA,OAAM,KAAK,CAAC,GAAN,CAAU,UAAC,IAAD;MAAA,OAAW,OAAO,KAAK,SAAZ,GAAwB,cAAc,CAAC,IAAD,EAAO,OAAP,CAAtC,GAAwD,SAAnE;IAAA,CAAV,CAAN;EAAA,CADsB,EAEtB,CACE,IAAI,CAAC,SAAL,CACE,KAAK,CAAC,GAAN,CAAU,UAAC,IAAD,EAAS;IAAA,IAAA,EAAA;;IAAC,OAAA,IAAI,IAAI;MAAE,OAAO,EAAE,CAAA,EAAA,GAAA,IAAI,CAAC,OAAL,MAAY,IAAZ,IAAY,EAAA,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAY,EAAA,CAAE,WAAF,EAAvB;MAAwC,MAAM,EAAE,IAAI,CAAC,MAArD;MAA6D,IAAI,EAAE,IAAI,CAAC;IAAxE,CAAR;EAAsF,CAA1G,CADF,CADF,EAIE,OAJF,CAFsB,CAAxB;EAUA,IAAM,OAAO,GAAG,aAAa,CAAC,QAAD,CAA7B;EAEA,OAAO,OAAO,CACZ;IAAA,OACE,OAAO,CAAC,GAAR,CAAY,UAAC,MAAD,EAAS,GAAT,EAAgB;MAC1B,IAAM,IAAI,GAAG,KAAK,CAAC,GAAD,CAAlB;;MACA,IAAI,MAAM,KAAK,IAAf,EAAqB;QACnB,yBAAyB,CAAC,IAAD,CAAzB;QACA,OAAO,SAAP;MACD;;MACD,OAAO,IAAI,IAAI,MAAR,GAAkB,IAAI,CAAC,GAAL,CAAS,oBAAT,CAA8B,IAAI,CAAC,MAAnC,EAA2C,MAA3C,CAAlB,GAAiF,SAAxF;IACD,CAPD,CADF;EAAA,CADY,EAUZ,CAAC,IAAI,CAAC,SAAL,CAAe,OAAf,CAAD,CAVY,CAAd;AAYD","sourceRoot":"","sourcesContent":["import { useMemo } from 'react';\nimport { useChainCalls } from './useChainCalls';\nimport { useChainId } from './useChainId';\nfunction warnOnInvalidContractCall(call) {\n    console.warn(`Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`);\n}\nfunction encodeCallData(call, chainId) {\n    if (!call) {\n        return undefined;\n    }\n    if (!call.address || !call.method) {\n        warnOnInvalidContractCall(call);\n        return undefined;\n    }\n    try {\n        return { address: call.address, data: call.abi.encodeFunctionData(call.method, call.args), chainId };\n    }\n    catch (_a) {\n        warnOnInvalidContractCall(call);\n        return undefined;\n    }\n}\n/**\n * Makes a call to a specific contract and returns the value. The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useChainCall} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param call a single call to a contract, also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCall} instead of this method as it is deprecated.\n * @returns the result of a call or undefined if call didn't return yet.\n */\nexport function useContractCall(call, queryParams = {}) {\n    return useContractCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific contracts and returns values. The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useChainCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls , also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCalls} instead of this method as it is deprecated.\n * @returns array of results. Undefined if call didn't return yet.\n */\nexport function useContractCalls(calls, queryParams = {}) {\n    const chainId = useChainId({ queryParams });\n    const rawCalls = useMemo(() => calls.map((call) => (chainId !== undefined ? encodeCallData(call, chainId) : undefined)), [\n        JSON.stringify(calls.map((call) => { var _a; return call && { address: (_a = call.address) === null || _a === void 0 ? void 0 : _a.toLowerCase(), method: call.method, args: call.args }; })),\n        chainId,\n    ]);\n    const results = useChainCalls(rawCalls);\n    return useMemo(() => results.map((result, idx) => {\n        const call = calls[idx];\n        if (result === '0x') {\n            warnOnInvalidContractCall(call);\n            return undefined;\n        }\n        return call && result ? call.abi.decodeFunctionResult(call.method, result) : undefined;\n    }), [JSON.stringify(results)]);\n}\n//# sourceMappingURL=useContractCall.js.map"]},"metadata":{},"sourceType":"module"}